// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within

const { assert } = require("chai");

// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')

contract('SupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var sku = 1
    var upc = 1
    const ownerID = accounts[0]
    const originFarmerID = accounts[1]
    const originFarmName = "John Doe"
    const originFarmInformation = "Yarray Valley"
    const originFarmLatitude = "-38.239770"
    const originFarmLongitude = "144.341490"
    var productID = sku + upc
    const productNotes = "Best beans for Espresso"
    const productPrice = web3.utils.toWei("2.0", "ether")
    var itemState = 0
    const distributorID = accounts[2]
    const retailerID = accounts[3]
    const consumerID = accounts[4]
    const emptyAddress = '0x00000000000000000000000000000000000000'

    ///Available Accounts
    ///==================
    ///(0) 0x27d8d15cbc94527cadf5ec14b69519ae23288b95
    ///(1) 0x018c2dabef4904ecbd7118350a0c54dbeae3549a
    ///(2) 0xce5144391b4ab80668965f2cc4f2cc102380ef0a
    ///(3) 0x460c31107dd048e34971e57da2f99f659add4f02
    ///(4) 0xd37b7b8c62be2fdde8daa9816483aebdbd356088
    ///(5) 0x27f184bdc0e7a931b507ddd689d76dba10514bcb
    ///(6) 0xfe0df793060c49edca5ac9c104dd8e3375349978
    ///(7) 0xbd58a85c96cc6727859d853086fe8560bc137632
    ///(8) 0xe07b5ee5f738b2f87f88b99aac9c64ff1e0c7917
    ///(9) 0xbd3ff2e3aded055244d66544c9c059fa0851da44

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Farmer: accounts[1] ", accounts[1])
    console.log("Distributor: accounts[2] ", accounts[2])
    console.log("Retailer: accounts[3] ", accounts[3])
    console.log("Consumer: accounts[4] ", accounts[4])

    // Add accounts to the different roles
    // 2nd Test
    it("Vaerify accounts addedd to access control roles", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Mark an item as Processed by calling function processtItem()
        assert.equal(await supplyChain.isFarmer(ownerID), true, "")
        assert.equal(await supplyChain.isDistributor(ownerID), true, "")
        assert.equal(await supplyChain.isRetailer(ownerID), true, "")
        assert.equal(await supplyChain.isConsumer(ownerID), true, "")

        await supplyChain.addFarmer(originFarmerID)
        await supplyChain.addDistributor(distributorID)
        await supplyChain.addRetailer(retailerID)
        await supplyChain.addConsumer(consumerID)

        assert.equal(await supplyChain.isFarmer(originFarmerID), true, "")
        assert.equal(await supplyChain.isDistributor(distributorID), true, "")
        assert.equal(await supplyChain.isRetailer(retailerID), true, "")
        assert.equal(await supplyChain.isConsumer(consumerID), true, "")
    })

    // 1st Test
    it("Testing smart contract function harvestItem() that allows a farmer to harvest coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false

        // Mark an item as Harvested by calling function harvestItem()
        var tx = await supplyChain.harvestItem(upc, originFarmerID, originFarmName, originFarmInformation, originFarmLatitude, originFarmLongitude, productNotes)
        
        if (tx.logs[0].event == "Harvested") {eventEmitted = true}

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne.sku, sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne.upc, upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne.ownerID, ownerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne.originFarmerID, originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne.originFarmName, originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferOne.originFarmInformation, originFarmInformation, 'Error: Missing or Invalid originFarmInformation')
        assert.equal(resultBufferOne.originFarmLatitude, originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude')
        assert.equal(resultBufferOne.originFarmLongitude, originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude')
        assert.equal(resultBufferTwo.itemState, 0, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')        
    })    

    // 2nd Test
    it("Testing smart contract function processItem() that allows a farmer to process coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false        

        // Mark an item as Processed by calling function processtItem()
        var tx = await supplyChain.processItem(upc)

        if (tx.logs[0].event == "Processed") {eventEmitted = true}

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferTwo.itemState, 1, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 3rd Test
    it("Testing smart contract function packItem() that allows a farmer to pack coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false                

        // Mark an item as Packed by calling function packItem()
        var tx = await supplyChain.packItem(upc)
        if (tx.logs[0].event == "Packed") {eventEmitted = true}

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferTwo.itemState, 2, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 4th Test
    it("Testing smart contract function sellItem() that allows a farmer to sell coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false

        // Mark an item as ForSale by calling function sellItem()
        var tx = await supplyChain.sellItem(upc,productPrice)
        if (tx.logs[0].event == "ForSale") {eventEmitted = true}


        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne.productPrice, productPrice, 'Error: Missing or Invalid productProce')
        assert.equal(resultBufferTwo.itemState, 3, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 5th Test
    it("Testing smart contract function buyItem() that allows a distributor to buy coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false

        // Mark an item as Sold by calling function buyItem()
        let balance = web3.utils.toWei("5.0", "ether");
        let balanceOfUser1BeforeTransaction = await web3.eth.getBalance(distributorID)
        let balanceOfUser2BeforeTransaction = await web3.eth.getBalance(originFarmerID)

        // console.log(web3.utils.fromWei(balanceOfUser1BeforeTransaction, "ether"))
        // console.log(web3.utils.fromWei(balanceOfUser2BeforeTransaction, "ether"))

        try {
            var tx = await supplyChain.buyItem(upc, {from: distributorID, value: balance})
            let balanceOfUser1AfterTransaction = await web3.eth.getBalance(distributorID)
            let balanceOfUser2AfterTransaction = await web3.eth.getBalance(originFarmerID)
            // console.log(web3.utils.fromWei(balanceOfUser1AfterTransaction, "ether"))
            // console.log(web3.utils.fromWei(balanceOfUser2AfterTransaction, "ether"))

            if (tx.logs[0].event == "Sold") {eventEmitted = true}
            const gasCost = tx.receipt.gasUsed * tx.receipt.effectiveGasPrice
        
            let value = balanceOfUser1BeforeTransaction - balanceOfUser1AfterTransaction - gasCost
            // console.log(Math.round(web3.utils.fromWei(value.toString(), "ether")))
            // console.log(Math.round(web3.utils.fromWei(productPrice, "ether")))
            assert.equal(Math.round(web3.utils.fromWei(productPrice, "ether")), Math.round(web3.utils.fromWei(value.toString(), "ether")), "Error: Amount of Ether Tranferred is not correct.")
            
        } catch (error){
            console.log(error)            
        }


        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        
        assert.equal(resultBufferTwo.itemState, 4, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 6th Test
    it("Testing smart contract function shipItem() that allows a distributor to ship coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false        

        // Mark an item as Sold by calling function shipItem()
        var tx = await supplyChain.shipItem(upc, {from:distributorID})
        if (tx.logs[0].event == "Shipped") {eventEmitted = true}

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultItem = await supplyChain.fetchItem.call(upc)

        // Verify the result set
        assert.equal(resultItem.itemState, 5, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')              
    })    

    // 7th Test
    it("Testing smart contract function receiveItem() that allows a retailer to mark coffee received", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false        

        // Mark an item as Sold by calling function receiveItem()
        var tx = await supplyChain.receiveItem(upc, {from:retailerID})
        if (tx.logs[0].event == "Received") {eventEmitted = true}

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultItem = await supplyChain.fetchItem.call(upc)

        // Verify the result set
        assert.equal(resultItem.itemState, 6, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 8th Test
    it("Testing smart contract function purchaseItem() that allows a consumer to purchase coffee", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false

        // Mark an item as Sold by calling function purchaseItem()
        var tx = await supplyChain.purchaseItem(upc, {from:consumerID})
        if (tx.logs[0].event == "Purchased") {eventEmitted = true}

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultItem = await supplyChain.fetchItem.call(upc)

        // Verify the result set
        assert.equal(resultItem.itemState, 7, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 9th Test
    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItem.call(upc, {from:accounts[8]})

        
        // Verify the result set:
        // Verify the owner is the now the Consumer but all other info is the same

        assert.equal(resultBufferOne.sku, sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne.upc, upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne.ownerID, consumerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne.originFarmerID, originFarmerID, 'Error: Missing or Invalid originFarmerID')
        assert.equal(resultBufferOne.originFarmName, originFarmName, 'Error: Missing or Invalid originFarmName')
        assert.equal(resultBufferOne.originFarmInformation, originFarmInformation, 'Error: Missing or Invalid originFarmInformation')
        assert.equal(resultBufferOne.originFarmLatitude, originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude')
        assert.equal(resultBufferOne.originFarmLongitude, originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude')
    })

    // 10th Test
    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItem.call(upc, {from:accounts[9]})
        
        // Verify the result set:
        assert.equal(resultBufferOne.distributorID, distributorID, 'Error: Missing or Invalid distributorID')
        assert.equal(resultBufferOne.retailerID, retailerID, 'Error: Missing or Invalid retailerID')
        assert.equal(resultBufferOne.consumerID, consumerID, 'Error: Missing or Invalid consumerID')
    })

});

